**1. 会话安全性**

- **会话劫持（Session Hijacking）和防御**
  
  1. 会话劫持是一种网络安全攻击，攻击者通过窃取用户的会话标识符来接管用户的会话
  
     会话劫持类型：
  
     ​    1.**基于网络的会话劫持**：攻击者通过监听网络流量（如使用中间人攻击）来获取会话标识符。

     ​    2.**基于服务器的会话劫持**：攻击者利用服务器端的漏洞（如SQL注入）来获取会话标识符。
  
     ​    3.**基于客户端的会话劫持**：攻击者利用客户端的漏洞（如XSS攻击）来窃取会话标识符。
  
  2. 防御措施：
    1. **使用HTTPS加密**：确保Session ID在传输过程中不被窃取。
    2. **设置Secure和HttpOnly标志**：防止Session ID通过不安全的连接发送，或被JavaScript访问。
    3. **定期更新Session ID**：每次用户登录后或发生敏感操作时，重新生成Session ID，防止旧的ID被利用。
    4. **设置Session超时时间**：减少攻击者利用Session ID的窗口期。
  
- **跨站脚本攻击（XSS）和防御**
  - XSS是指攻击者通过在页面中插入恶意Script代码，用户浏览页面时代码执行，可能会窃取用户的Session ID。
  
    XSS攻击类型：
  
    ​    1.**Reflected XSS（反射型 XSS 攻击）**：由于服务端接收到客户端的不安全输入，在客户端触发执行从而发起 Web 攻击。

    ​    2.**Stored XSS（存储型 XSS 攻击）**：过提交带有恶意脚本的内容存储在服务器上，当其他人看到这些内容时发起 Web 攻击。
  
    ​    3.**DOM XSS**：前端JavaScript对用户输入数据的不当处理引起的Web攻击。
  
  - 防御措施：
    1. **输入验证和输出编码**：对用户输入的数据进行严格的验证和过滤，防止恶意代码注入。
    2. **使用HttpOnly标志**：防止JavaScript访问敏感的Cookie。
    3. **内容安全策略（CSP）**：通过CSP限制网页中允许执行的脚本来源，防止恶意脚本运行。
  
- **跨站请求伪造（CSRF）和防御**
  - CSRF是指攻击者挟持用户在登录状态下发起非本意操作，冒充用户执行操作。
  
    CSRF攻击类型：
       1.**GET型**：攻击者构造一个恶意链接，诱导用户点击触发这个链接，攻击者可以借助用户的会话状态伪造请求。
  
       2.**POST型**：攻击者通过在网页中嵌入伪造的表单来实现CSRF攻击。
  
  - 防御措施：
    1. ##### 检测referer字段：严格检测referer字段，防止可以被绕过。
    2. **添加验证码机制：添加验证码来识别是不是用户主动去发起这个请求。**
    3. ##### **添加token校验**： 添加token伪随机参数，后端校验token有效性。

---

**2. 分布式会话管理**

在分布式系统中，多个服务器可能同时处理用户请求，如何保持会话的连续性和同步是一个重要问题：

- **分布式环境下的会话同步问题**
  - 在分布式环境中，用户的请求可能被不同的服务器处理。如果Session信息存储在单个服务器上，其他服务器无法访问该会话数据，无法实现Session的共享和同步。

- **Session集群解决方案**
  - 解决方案包括：
    1. **粘性会话（Sticky Session）**：使用负载均衡器将同一客户端的所有请求都转发到同一个服务器，避免会话不同步的问题。
    2. **Session复制**：将Session数据复制到集群中的所有服务器，以便每个服务器都能访问相同的会话数据。但复制的开销较大，适合小规模集群。
    3. **集中式Session存储**：将会话信息存储在一个集中式的数据库或缓存系统（如Redis、Memcached）中，所有服务器共享该存储，确保会话数据同步。

- **使用Redis等缓存技术实现分布式会话**
  - Redis是一种高效的内存缓存系统，常用于分布式会话存储。它通过将Session数据存储在Redis缓存中，提供快速的读写访问，无论是对Session的注销、更新都会同步到Redis中，从而达到Session共享的目的。

---

**3. 会话状态的序列化和反序列化**

- **会话状态的序列化和反序列化**
  
  - **序列化**是将内存中的对象转换为字节形式的过程，**反序列化**则是字节序列转化为对象的过程。
  
- **为什么需要序列化会话状态**
  - 在服务器重启、崩溃或迁移时使用序列化将session保存放在硬盘，服务器重启后重新加载，可以保证用户信息不会丢失。

- **Java对象序列化**
  
  - Java 序列化是一种将对象转换为字节流的过程，以便可以将对象保存到磁盘上，将其传输到网络上，或者将其存储在内存中，以后再进行反序列化，将字节流重新转换为对象。
  - 序列化在 Java 中是通过` java.io.Serializable `接口来实现的，该接口没有任何方法，只是一个标记接口，用于标识类可以被序列化。
  - 序列化对象时，可以把它包装成一个特殊文件，可以保存、传输或存储。反序列化则是打开这个文件，读取序列化的数据，然后将其还原为对象，以便在程序中使用。
  
- **自定义序列化策略**
  
  - 当需要对特定的类或属性进行自定义的序列化和反序列化控制时，Java允许通过实现`java.io.Externalizable`接口或自定义`readObject`和`writeObject`方法来控制序列化的过程
  
    1.**Externalizable接口**：开发者自己实现`writeExternal`和`readExternal`方法，这种方式可以显著提升性能，因为序列化的数据更加精简。
  
    2.**自定义writeObject和readObject方法**:这种方式在实现Serializable接口时，可以保持默认序列化的部分功能，同时对敏感数据进行加密或其他处理。